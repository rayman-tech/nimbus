// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToProject = `-- name: AddUserToProject :exec
INSERT INTO user_projects (user_id, project_id)
VALUES ($1, $2)
`

type AddUserToProjectParams struct {
	UserID    uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) AddUserToProject(ctx context.Context, arg AddUserToProjectParams) error {
	_, err := q.db.Exec(ctx, addUserToProject, arg.UserID, arg.ProjectID)
	return err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
  id, name
) VALUES (
  $1, $2
)
RETURNING id, name
`

type CreateProjectParams struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject, arg.ID, arg.Name)
	var i Project
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const createService = `-- name: CreateService :one
INSERT INTO services (
  id, project_id, project_branch, service_name, node_ports, ingress
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, project_id, project_branch, service_name, node_ports, ingress
`

type CreateServiceParams struct {
	ID            uuid.UUID
	ProjectID     uuid.UUID
	ProjectBranch string
	ServiceName   string
	NodePorts     []int32
	Ingress       pgtype.Text
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.ID,
		arg.ProjectID,
		arg.ProjectBranch,
		arg.ServiceName,
		arg.NodePorts,
		arg.Ingress,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.ServiceName,
		&i.NodePorts,
		&i.Ingress,
	)
	return i, err
}

const createVolume = `-- name: CreateVolume :one
INSERT INTO volumes (
  identifier, volume_name, project_id, project_branch, size
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING identifier, volume_name, project_id, project_branch, size
`

type CreateVolumeParams struct {
	Identifier    uuid.UUID
	VolumeName    string
	ProjectID     uuid.UUID
	ProjectBranch string
	Size          int32
}

func (q *Queries) CreateVolume(ctx context.Context, arg CreateVolumeParams) (Volume, error) {
	row := q.db.QueryRow(ctx, createVolume,
		arg.Identifier,
		arg.VolumeName,
		arg.ProjectID,
		arg.ProjectBranch,
		arg.Size,
	)
	var i Volume
	err := row.Scan(
		&i.Identifier,
		&i.VolumeName,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.Size,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteServiceById = `-- name: DeleteServiceById :exec
DELETE FROM services
WHERE id = $1
`

func (q *Queries) DeleteServiceById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteServiceById, id)
	return err
}

const deleteServiceByName = `-- name: DeleteServiceByName :exec
DELETE FROM services
WHERE service_name = $1 AND project_id = $2 AND project_branch = $3
`

type DeleteServiceByNameParams struct {
	ServiceName   string
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) DeleteServiceByName(ctx context.Context, arg DeleteServiceByNameParams) error {
	_, err := q.db.Exec(ctx, deleteServiceByName, arg.ServiceName, arg.ProjectID, arg.ProjectBranch)
	return err
}

const deleteUnusedVolumes = `-- name: DeleteUnusedVolumes :exec
DELETE FROM volumes
WHERE project_id = $1 AND project_branch = $2 AND NOT volume_name = ANY($3::text[])
`

type DeleteUnusedVolumesParams struct {
	ProjectID     uuid.UUID
	ProjectBranch string
	Column3       []string
}

func (q *Queries) DeleteUnusedVolumes(ctx context.Context, arg DeleteUnusedVolumesParams) error {
	_, err := q.db.Exec(ctx, deleteUnusedVolumes, arg.ProjectID, arg.ProjectBranch, arg.Column3)
	return err
}

const getProject = `-- name: GetProject :one
SELECT id, name FROM projects
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id uuid.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getProjectByName = `-- name: GetProjectByName :one
SELECT id, name FROM projects
WHERE name = $1 LIMIT 1
`

func (q *Queries) GetProjectByName(ctx context.Context, name string) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByName, name)
	var i Project
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getProjectsByUser = `-- name: GetProjectsByUser :many
SELECT p.id, p.name FROM projects p
JOIN user_projects up ON p.id = up.project_id
WHERE up.user_id = $1
ORDER BY p.name
`

func (q *Queries) GetProjectsByUser(ctx context.Context, userID uuid.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getService = `-- name: GetService :one
SELECT id, project_id, project_branch, service_name, node_ports, ingress FROM services
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetService(ctx context.Context, id uuid.UUID) (Service, error) {
	row := q.db.QueryRow(ctx, getService, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.ServiceName,
		&i.NodePorts,
		&i.Ingress,
	)
	return i, err
}

const getServiceByName = `-- name: GetServiceByName :one
SELECT id, project_id, project_branch, service_name, node_ports, ingress FROM services
WHERE service_name = $1 AND project_id = $2 AND project_branch = $3
LIMIT 1
`

type GetServiceByNameParams struct {
	ServiceName   string
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) GetServiceByName(ctx context.Context, arg GetServiceByNameParams) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByName, arg.ServiceName, arg.ProjectID, arg.ProjectBranch)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.ServiceName,
		&i.NodePorts,
		&i.Ingress,
	)
	return i, err
}

const getServicesByProject = `-- name: GetServicesByProject :many
SELECT id, project_id, project_branch, service_name, node_ports, ingress FROM services
WHERE project_id = $1 AND project_branch = $2
ORDER BY service_name
`

type GetServicesByProjectParams struct {
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) GetServicesByProject(ctx context.Context, arg GetServicesByProjectParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, getServicesByProject, arg.ProjectID, arg.ProjectBranch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ProjectBranch,
			&i.ServiceName,
			&i.NodePorts,
			&i.Ingress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicesByUser = `-- name: GetServicesByUser :many
SELECT s.id, s.project_id, s.project_branch, s.service_name, s.node_ports, s.ingress, p.name AS project_name FROM services s
JOIN projects p ON s.project_id = p.id
JOIN user_projects up ON up.project_id = p.id
WHERE up.user_id = $1
ORDER BY p.name, s.service_name
`

type GetServicesByUserRow struct {
	ID            uuid.UUID
	ProjectID     uuid.UUID
	ProjectBranch string
	ServiceName   string
	NodePorts     []int32
	Ingress       pgtype.Text
	ProjectName   string
}

func (q *Queries) GetServicesByUser(ctx context.Context, userID uuid.UUID) ([]GetServicesByUserRow, error) {
	rows, err := q.db.Query(ctx, getServicesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServicesByUserRow
	for rows.Next() {
		var i GetServicesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ProjectBranch,
			&i.ServiceName,
			&i.NodePorts,
			&i.Ingress,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnusedVolumeIdentifiers = `-- name: GetUnusedVolumeIdentifiers :many
SELECT identifier FROM volumes
WHERE project_id = $1 AND project_branch = $2 AND NOT volume_name = ANY($3::text[])
`

type GetUnusedVolumeIdentifiersParams struct {
	ProjectID     uuid.UUID
	ProjectBranch string
	Column3       []string
}

func (q *Queries) GetUnusedVolumeIdentifiers(ctx context.Context, arg GetUnusedVolumeIdentifiersParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getUnusedVolumeIdentifiers, arg.ProjectID, arg.ProjectBranch, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var identifier uuid.UUID
		if err := rows.Scan(&identifier); err != nil {
			return nil, err
		}
		items = append(items, identifier)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByApiKey = `-- name: GetUserByApiKey :one
SELECT id, username, api_key FROM users
WHERE api_key = $1 LIMIT 1
`

func (q *Queries) GetUserByApiKey(ctx context.Context, apiKey string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByApiKey, apiKey)
	var i User
	err := row.Scan(&i.ID, &i.Username, &i.ApiKey)
	return i, err
}

const getVolumeIdentifier = `-- name: GetVolumeIdentifier :one
SELECT identifier FROM volumes
WHERE volume_name = $1 AND project_id = $2 AND project_branch = $3
`

type GetVolumeIdentifierParams struct {
	VolumeName    string
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) GetVolumeIdentifier(ctx context.Context, arg GetVolumeIdentifierParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getVolumeIdentifier, arg.VolumeName, arg.ProjectID, arg.ProjectBranch)
	var identifier uuid.UUID
	err := row.Scan(&identifier)
	return identifier, err
}

const isUserInProject = `-- name: IsUserInProject :one
SELECT EXISTS (
  SELECT 1 FROM user_projects
  WHERE user_id = $1 AND project_id = $2
)
`

type IsUserInProjectParams struct {
	UserID    uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) IsUserInProject(ctx context.Context, arg IsUserInProjectParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserInProject, arg.UserID, arg.ProjectID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const setServiceIngress = `-- name: SetServiceIngress :exec
UPDATE services SET
  ingress = $2
WHERE id = $1 RETURNING id, project_id, project_branch, service_name, node_ports, ingress
`

type SetServiceIngressParams struct {
	ID      uuid.UUID
	Ingress pgtype.Text
}

func (q *Queries) SetServiceIngress(ctx context.Context, arg SetServiceIngressParams) error {
	_, err := q.db.Exec(ctx, setServiceIngress, arg.ID, arg.Ingress)
	return err
}

const setServiceNodePorts = `-- name: SetServiceNodePorts :exec
UPDATE services SET
  node_ports = $2
WHERE id = $1 RETURNING id, project_id, project_branch, service_name, node_ports, ingress
`

type SetServiceNodePortsParams struct {
	ID        uuid.UUID
	NodePorts []int32
}

func (q *Queries) SetServiceNodePorts(ctx context.Context, arg SetServiceNodePortsParams) error {
	_, err := q.db.Exec(ctx, setServiceNodePorts, arg.ID, arg.NodePorts)
	return err
}
