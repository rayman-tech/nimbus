// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
  id, name, api_key
) VALUES (
  $1, $2, $3
)
RETURNING id, name, api_key
`

type CreateProjectParams struct {
	ID     pgtype.UUID
	Name   string
	ApiKey string
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject, arg.ID, arg.Name, arg.ApiKey)
	var i Project
	err := row.Scan(&i.ID, &i.Name, &i.ApiKey)
	return i, err
}

const createService = `-- name: CreateService :one
INSERT INTO services (
  id, project_id, project_branch, name, node_ports, ingress
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, project_id, project_branch, name, node_ports, ingress
`

type CreateServiceParams struct {
	ID            pgtype.UUID
	ProjectID     string
	ProjectBranch string
	Name          string
	NodePorts     []int32
	Ingress       pgtype.Text
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.ID,
		arg.ProjectID,
		arg.ProjectBranch,
		arg.Name,
		arg.NodePorts,
		arg.Ingress,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.Name,
		&i.NodePorts,
		&i.Ingress,
	)
	return i, err
}

const createVolume = `-- name: CreateVolume :one
INSERT INTO volumes (
  identifier, volume_name, project_id, project_branch, size
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING identifier, volume_name, project_id, project_branch, size
`

type CreateVolumeParams struct {
	Identifier    pgtype.UUID
	VolumeName    string
	ProjectID     string
	ProjectBranch string
	Size          int32
}

func (q *Queries) CreateVolume(ctx context.Context, arg CreateVolumeParams) (Volume, error) {
	row := q.db.QueryRow(ctx, createVolume,
		arg.Identifier,
		arg.VolumeName,
		arg.ProjectID,
		arg.ProjectBranch,
		arg.Size,
	)
	var i Volume
	err := row.Scan(
		&i.Identifier,
		&i.VolumeName,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.Size,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteServiceById = `-- name: DeleteServiceById :exec
DELETE FROM services
WHERE id = $1
`

func (q *Queries) DeleteServiceById(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteServiceById, id)
	return err
}

const deleteServiceByName = `-- name: DeleteServiceByName :exec
DELETE FROM services
WHERE name = $1 AND project_id = $2 AND project_branch = $3
`

type DeleteServiceByNameParams struct {
	Name          string
	ProjectID     string
	ProjectBranch string
}

func (q *Queries) DeleteServiceByName(ctx context.Context, arg DeleteServiceByNameParams) error {
	_, err := q.db.Exec(ctx, deleteServiceByName, arg.Name, arg.ProjectID, arg.ProjectBranch)
	return err
}

const deleteUnusedVolumes = `-- name: DeleteUnusedVolumes :exec
DELETE FROM volumes
WHERE project_id = $1 AND project_branch = $2 AND NOT volume_name = ANY($3::text[])
`

type DeleteUnusedVolumesParams struct {
	ProjectID     string
	ProjectBranch string
	Column3       []string
}

func (q *Queries) DeleteUnusedVolumes(ctx context.Context, arg DeleteUnusedVolumesParams) error {
	_, err := q.db.Exec(ctx, deleteUnusedVolumes, arg.ProjectID, arg.ProjectBranch, arg.Column3)
	return err
}

const getProject = `-- name: GetProject :one
SELECT id, name, api_key FROM projects
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id pgtype.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(&i.ID, &i.Name, &i.ApiKey)
	return i, err
}

const getProjectByApiKey = `-- name: GetProjectByApiKey :one
SELECT id, name, api_key FROM projects
WHERE api_key = $1 LIMIT 1
`

func (q *Queries) GetProjectByApiKey(ctx context.Context, apiKey string) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByApiKey, apiKey)
	var i Project
	err := row.Scan(&i.ID, &i.Name, &i.ApiKey)
	return i, err
}

const getService = `-- name: GetService :one
SELECT id, project_id, project_branch, name, node_ports, ingress FROM services
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetService(ctx context.Context, id pgtype.UUID) (Service, error) {
	row := q.db.QueryRow(ctx, getService, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.Name,
		&i.NodePorts,
		&i.Ingress,
	)
	return i, err
}

const getServicesByProject = `-- name: GetServicesByProject :many
SELECT id, project_id, project_branch, name, node_ports, ingress FROM services
WHERE project_id = $1 AND project_branch = $2
ORDER BY name
`

type GetServicesByProjectParams struct {
	ProjectID     string
	ProjectBranch string
}

func (q *Queries) GetServicesByProject(ctx context.Context, arg GetServicesByProjectParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, getServicesByProject, arg.ProjectID, arg.ProjectBranch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ProjectBranch,
			&i.Name,
			&i.NodePorts,
			&i.Ingress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnusedVolumeIdentifiers = `-- name: GetUnusedVolumeIdentifiers :many
SELECT identifier FROM volumes
WHERE project_id = $1 AND project_branch = $2 AND NOT volume_name = ANY($3::text[])
`

type GetUnusedVolumeIdentifiersParams struct {
	ProjectID     string
	ProjectBranch string
	Column3       []string
}

func (q *Queries) GetUnusedVolumeIdentifiers(ctx context.Context, arg GetUnusedVolumeIdentifiersParams) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getUnusedVolumeIdentifiers, arg.ProjectID, arg.ProjectBranch, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var identifier pgtype.UUID
		if err := rows.Scan(&identifier); err != nil {
			return nil, err
		}
		items = append(items, identifier)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVolumeIdentifier = `-- name: GetVolumeIdentifier :one
SELECT identifier FROM volumes
WHERE volume_name = $1 AND project_id = $2 AND project_branch = $3
`

type GetVolumeIdentifierParams struct {
	VolumeName    string
	ProjectID     string
	ProjectBranch string
}

func (q *Queries) GetVolumeIdentifier(ctx context.Context, arg GetVolumeIdentifierParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getVolumeIdentifier, arg.VolumeName, arg.ProjectID, arg.ProjectBranch)
	var identifier pgtype.UUID
	err := row.Scan(&identifier)
	return identifier, err
}

const setServiceIngress = `-- name: SetServiceIngress :exec
UPDATE services SET
  ingress = $2
WHERE id = $1 RETURNING id, project_id, project_branch, name, node_ports, ingress
`

type SetServiceIngressParams struct {
	ID      pgtype.UUID
	Ingress pgtype.Text
}

func (q *Queries) SetServiceIngress(ctx context.Context, arg SetServiceIngressParams) error {
	_, err := q.db.Exec(ctx, setServiceIngress, arg.ID, arg.Ingress)
	return err
}

const setServiceNodePorts = `-- name: SetServiceNodePorts :exec
UPDATE services SET
  node_ports = $2
WHERE id = $1 RETURNING id, project_id, project_branch, name, node_ports, ingress
`

type SetServiceNodePortsParams struct {
	ID        pgtype.UUID
	NodePorts []int32
}

func (q *Queries) SetServiceNodePorts(ctx context.Context, arg SetServiceNodePortsParams) error {
	_, err := q.db.Exec(ctx, setServiceNodePorts, arg.ID, arg.NodePorts)
	return err
}
