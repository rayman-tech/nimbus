// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToProject = `-- name: AddUserToProject :exec
INSERT INTO user_projects (user_id, project_id)
  VALUES ($1, $2)
`

type AddUserToProjectParams struct {
	UserID    uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) AddUserToProject(ctx context.Context, arg AddUserToProjectParams) error {
	_, err := q.db.Exec(ctx, addUserToProject, arg.UserID, arg.ProjectID)
	return err
}

const checkProjectsTableExists = `-- name: CheckProjectsTableExists :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      information_schema.tables
    WHERE
      table_schema = 'public'
      AND table_name = 'projects')
`

func (q *Queries) CheckProjectsTableExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, checkProjectsTableExists)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (id, name)
  VALUES ($1, $2)
RETURNING
  id, name
`

type CreateProjectParams struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject, arg.ID, arg.Name)
	var i Project
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const createService = `-- name: CreateService :one
INSERT INTO services (id, project_id, project_branch, service_name, node_ports, ingress)
  VALUES ($1, $2, $3, $4, $5, $6)
RETURNING
  id, project_id, project_branch, service_name, node_ports, ingress
`

type CreateServiceParams struct {
	ID            uuid.UUID
	ProjectID     uuid.UUID
	ProjectBranch string
	ServiceName   string
	NodePorts     []int32
	Ingress       pgtype.Text
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.ID,
		arg.ProjectID,
		arg.ProjectBranch,
		arg.ServiceName,
		arg.NodePorts,
		arg.Ingress,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.ServiceName,
		&i.NodePorts,
		&i.Ingress,
	)
	return i, err
}

const createVolume = `-- name: CreateVolume :one
INSERT INTO volumes (identifier, volume_name, project_id, project_branch, size)
  VALUES ($1, $2, $3, $4, $5)
RETURNING
  identifier, volume_name, project_id, project_branch, size
`

type CreateVolumeParams struct {
	Identifier    uuid.UUID
	VolumeName    string
	ProjectID     uuid.UUID
	ProjectBranch string
	Size          int32
}

func (q *Queries) CreateVolume(ctx context.Context, arg CreateVolumeParams) (Volume, error) {
	row := q.db.QueryRow(ctx, createVolume,
		arg.Identifier,
		arg.VolumeName,
		arg.ProjectID,
		arg.ProjectBranch,
		arg.Size,
	)
	var i Volume
	err := row.Scan(
		&i.Identifier,
		&i.VolumeName,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.Size,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteServiceById = `-- name: DeleteServiceById :exec
DELETE FROM services
WHERE id = $1
`

func (q *Queries) DeleteServiceById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteServiceById, id)
	return err
}

const deleteServiceByName = `-- name: DeleteServiceByName :exec
DELETE FROM services
WHERE service_name = $1
  AND project_id = $2
  AND project_branch = $3
`

type DeleteServiceByNameParams struct {
	ServiceName   string
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) DeleteServiceByName(ctx context.Context, arg DeleteServiceByNameParams) error {
	_, err := q.db.Exec(ctx, deleteServiceByName, arg.ServiceName, arg.ProjectID, arg.ProjectBranch)
	return err
}

const deleteUnusedVolumes = `-- name: DeleteUnusedVolumes :exec
DELETE FROM volumes
WHERE project_id = $1
  AND project_branch = $2
  AND NOT volume_name = ANY ($3::text[])
`

type DeleteUnusedVolumesParams struct {
	ProjectID     uuid.UUID
	ProjectBranch string
	Column3       []string
}

func (q *Queries) DeleteUnusedVolumes(ctx context.Context, arg DeleteUnusedVolumesParams) error {
	_, err := q.db.Exec(ctx, deleteUnusedVolumes, arg.ProjectID, arg.ProjectBranch, arg.Column3)
	return err
}

const getApiKeyExistance = `-- name: GetApiKeyExistance :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      users
    WHERE
      api_key = $1)
`

func (q *Queries) GetApiKeyExistance(ctx context.Context, apiKey string) (bool, error) {
	row := q.db.QueryRow(ctx, getApiKeyExistance, apiKey)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getProject = `-- name: GetProject :one
SELECT
  id, name
FROM
  projects
WHERE
  id = $1
LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id uuid.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getProjectBranches = `-- name: GetProjectBranches :many
SELECT
  project_branch
FROM
  services s
WHERE
  s.project_id = $1
UNION
SELECT
  project_branch
FROM
  volumes v
WHERE
  v.project_id = $1
`

func (q *Queries) GetProjectBranches(ctx context.Context, projectID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getProjectBranches, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var project_branch string
		if err := rows.Scan(&project_branch); err != nil {
			return nil, err
		}
		items = append(items, project_branch)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectById = `-- name: GetProjectById :one
SELECT
  id,
  name
FROM
  projects
WHERE
  id = $1
`

func (q *Queries) GetProjectById(ctx context.Context, id uuid.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectById, id)
	var i Project
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getProjectByName = `-- name: GetProjectByName :one
SELECT
  id, name
FROM
  projects
WHERE
  name = $1
LIMIT 1
`

func (q *Queries) GetProjectByName(ctx context.Context, name string) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByName, name)
	var i Project
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getProjectsByUser = `-- name: GetProjectsByUser :many
SELECT
  p.id, p.name
FROM
  projects p
  JOIN user_projects up ON p.id = up.project_id
WHERE
  up.user_id = $1
ORDER BY
  p.name
`

func (q *Queries) GetProjectsByUser(ctx context.Context, userID uuid.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getService = `-- name: GetService :one
SELECT
  id, project_id, project_branch, service_name, node_ports, ingress
FROM
  services
WHERE
  id = $1
LIMIT 1
`

func (q *Queries) GetService(ctx context.Context, id uuid.UUID) (Service, error) {
	row := q.db.QueryRow(ctx, getService, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.ServiceName,
		&i.NodePorts,
		&i.Ingress,
	)
	return i, err
}

const getServiceByName = `-- name: GetServiceByName :one
SELECT
  id, project_id, project_branch, service_name, node_ports, ingress
FROM
  services
WHERE
  service_name = $1
  AND project_id = $2
  AND project_branch = $3
LIMIT 1
`

type GetServiceByNameParams struct {
	ServiceName   string
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) GetServiceByName(ctx context.Context, arg GetServiceByNameParams) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByName, arg.ServiceName, arg.ProjectID, arg.ProjectBranch)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.ServiceName,
		&i.NodePorts,
		&i.Ingress,
	)
	return i, err
}

const getServicesByProject = `-- name: GetServicesByProject :many
SELECT
  id, project_id, project_branch, service_name, node_ports, ingress
FROM
  services
WHERE
  project_id = $1
  AND project_branch = $2
ORDER BY
  service_name
`

type GetServicesByProjectParams struct {
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) GetServicesByProject(ctx context.Context, arg GetServicesByProjectParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, getServicesByProject, arg.ProjectID, arg.ProjectBranch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ProjectBranch,
			&i.ServiceName,
			&i.NodePorts,
			&i.Ingress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicesByUser = `-- name: GetServicesByUser :many
SELECT
  s.id, s.project_id, s.project_branch, s.service_name, s.node_ports, s.ingress,
  p.name AS project_name
FROM
  services s
  JOIN projects p ON s.project_id = p.id
  JOIN user_projects up ON up.project_id = p.id
WHERE
  up.user_id = $1
ORDER BY
  p.name,
  s.service_name
`

type GetServicesByUserRow struct {
	ID            uuid.UUID
	ProjectID     uuid.UUID
	ProjectBranch string
	ServiceName   string
	NodePorts     []int32
	Ingress       pgtype.Text
	ProjectName   string
}

func (q *Queries) GetServicesByUser(ctx context.Context, userID uuid.UUID) ([]GetServicesByUserRow, error) {
	rows, err := q.db.Query(ctx, getServicesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServicesByUserRow
	for rows.Next() {
		var i GetServicesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ProjectBranch,
			&i.ServiceName,
			&i.NodePorts,
			&i.Ingress,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnusedVolumeIdentifiers = `-- name: GetUnusedVolumeIdentifiers :many
SELECT
  identifier
FROM
  volumes
WHERE
  project_id = $1
  AND project_branch = $2
  AND NOT volume_name = ANY ($3::text[])
`

type GetUnusedVolumeIdentifiersParams struct {
	ProjectID     uuid.UUID
	ProjectBranch string
	Column3       []string
}

func (q *Queries) GetUnusedVolumeIdentifiers(ctx context.Context, arg GetUnusedVolumeIdentifiersParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getUnusedVolumeIdentifiers, arg.ProjectID, arg.ProjectBranch, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var identifier uuid.UUID
		if err := rows.Scan(&identifier); err != nil {
			return nil, err
		}
		items = append(items, identifier)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByApiKey = `-- name: GetUserByApiKey :one
SELECT
  id, username, api_key
FROM
  users
WHERE
  api_key = $1
LIMIT 1
`

func (q *Queries) GetUserByApiKey(ctx context.Context, apiKey string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByApiKey, apiKey)
	var i User
	err := row.Scan(&i.ID, &i.Username, &i.ApiKey)
	return i, err
}

const getVolumeIdentifier = `-- name: GetVolumeIdentifier :one
SELECT
  identifier
FROM
  volumes
WHERE
  volume_name = $1
  AND project_id = $2
  AND project_branch = $3
`

type GetVolumeIdentifierParams struct {
	VolumeName    string
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) GetVolumeIdentifier(ctx context.Context, arg GetVolumeIdentifierParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getVolumeIdentifier, arg.VolumeName, arg.ProjectID, arg.ProjectBranch)
	var identifier uuid.UUID
	err := row.Scan(&identifier)
	return identifier, err
}

const isUserInProject = `-- name: IsUserInProject :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      user_projects
    WHERE
      user_id = $1
      AND project_id = $2)
`

type IsUserInProjectParams struct {
	UserID    uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) IsUserInProject(ctx context.Context, arg IsUserInProjectParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserInProject, arg.UserID, arg.ProjectID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const setServiceIngress = `-- name: SetServiceIngress :exec
UPDATE
  services
SET
  ingress = $2
WHERE
  id = $1
RETURNING
  id, project_id, project_branch, service_name, node_ports, ingress
`

type SetServiceIngressParams struct {
	ID      uuid.UUID
	Ingress pgtype.Text
}

func (q *Queries) SetServiceIngress(ctx context.Context, arg SetServiceIngressParams) error {
	_, err := q.db.Exec(ctx, setServiceIngress, arg.ID, arg.Ingress)
	return err
}

const setServiceNodePorts = `-- name: SetServiceNodePorts :exec
UPDATE
  services
SET
  node_ports = $2
WHERE
  id = $1
RETURNING
  id, project_id, project_branch, service_name, node_ports, ingress
`

type SetServiceNodePortsParams struct {
	ID        uuid.UUID
	NodePorts []int32
}

func (q *Queries) SetServiceNodePorts(ctx context.Context, arg SetServiceNodePortsParams) error {
	_, err := q.db.Exec(ctx, setServiceNodePorts, arg.ID, arg.NodePorts)
	return err
}
