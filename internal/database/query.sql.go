// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToProject = `-- name: AddUserToProject :exec
INSERT INTO user_projects (user_id, project_id)
  VALUES ($1, $2)
`

type AddUserToProjectParams struct {
	UserID    uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) AddUserToProject(ctx context.Context, arg AddUserToProjectParams) error {
	_, err := q.db.Exec(ctx, addUserToProject, arg.UserID, arg.ProjectID)
	return err
}

const checkProjectsTableExists = `-- name: CheckProjectsTableExists :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      information_schema.tables
    WHERE
      table_schema = 'public'
      AND table_name = 'projects')
`

func (q *Queries) CheckProjectsTableExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, checkProjectsTableExists)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createKubernetesService = `-- name: CreateKubernetesService :one
INSERT INTO kubernetes_services (id, project_id, project_branch, service_name, node_ports, ingress)
  VALUES ($1, $2, $3, $4, $5, $6)
RETURNING
  id, project_id, project_branch, service_name, runtime, node_ports, ingress
`

type CreateKubernetesServiceParams struct {
	ID            uuid.UUID
	ProjectID     uuid.UUID
	ProjectBranch string
	ServiceName   string
	NodePorts     []int32
	Ingress       pgtype.Text
}

func (q *Queries) CreateKubernetesService(ctx context.Context, arg CreateKubernetesServiceParams) (KubernetesService, error) {
	row := q.db.QueryRow(ctx, createKubernetesService,
		arg.ID,
		arg.ProjectID,
		arg.ProjectBranch,
		arg.ServiceName,
		arg.NodePorts,
		arg.Ingress,
	)
	var i KubernetesService
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.ServiceName,
		&i.Runtime,
		&i.NodePorts,
		&i.Ingress,
	)
	return i, err
}

const createKubernetesVolume = `-- name: CreateKubernetesVolume :one
INSERT INTO volumes (identifier, volume_name, project_id, project_branch, size)
  VALUES ($1, $2, $3, $4, $5)
RETURNING
  identifier, runtime, volume_name, project_id, project_branch, size
`

type CreateKubernetesVolumeParams struct {
	Identifier    uuid.UUID
	VolumeName    string
	ProjectID     uuid.UUID
	ProjectBranch string
	Size          int32
}

func (q *Queries) CreateKubernetesVolume(ctx context.Context, arg CreateKubernetesVolumeParams) (Volume, error) {
	row := q.db.QueryRow(ctx, createKubernetesVolume,
		arg.Identifier,
		arg.VolumeName,
		arg.ProjectID,
		arg.ProjectBranch,
		arg.Size,
	)
	var i Volume
	err := row.Scan(
		&i.Identifier,
		&i.Runtime,
		&i.VolumeName,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.Size,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (id, name)
  VALUES ($1, $2)
RETURNING
  id, name
`

type CreateProjectParams struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject, arg.ID, arg.Name)
	var i Project
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const deleteKubernetesServiceById = `-- name: DeleteKubernetesServiceById :exec
DELETE FROM kubernetes_services
WHERE id = $1
`

func (q *Queries) DeleteKubernetesServiceById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteKubernetesServiceById, id)
	return err
}

const deleteKubernetesServiceByName = `-- name: DeleteKubernetesServiceByName :exec
DELETE FROM kubernetes_services
WHERE service_name = $1
  AND project_id = $2
  AND project_branch = $3
`

type DeleteKubernetesServiceByNameParams struct {
	ServiceName   string
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) DeleteKubernetesServiceByName(ctx context.Context, arg DeleteKubernetesServiceByNameParams) error {
	_, err := q.db.Exec(ctx, deleteKubernetesServiceByName, arg.ServiceName, arg.ProjectID, arg.ProjectBranch)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteUnusedKubernetesVolumes = `-- name: DeleteUnusedKubernetesVolumes :exec
DELETE FROM kubernetes_volumes
WHERE project_id = $1
  AND project_branch = $2
  AND NOT volume_name = ANY ($3::text[])
`

type DeleteUnusedKubernetesVolumesParams struct {
	ProjectID      uuid.UUID
	ProjectBranch  string
	ExcludeVolumes []string
}

func (q *Queries) DeleteUnusedKubernetesVolumes(ctx context.Context, arg DeleteUnusedKubernetesVolumesParams) error {
	_, err := q.db.Exec(ctx, deleteUnusedKubernetesVolumes, arg.ProjectID, arg.ProjectBranch, arg.ExcludeVolumes)
	return err
}

const getApiKeyExistance = `-- name: GetApiKeyExistance :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      users
    WHERE
      api_key = $1)
`

func (q *Queries) GetApiKeyExistance(ctx context.Context, apiKey string) (bool, error) {
	row := q.db.QueryRow(ctx, getApiKeyExistance, apiKey)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getKubernetesProjectBranches = `-- name: GetKubernetesProjectBranches :many
SELECT
  project_branch
FROM
  kubernetes_services s
WHERE
  s.project_id = $1
UNION
SELECT
  project_branch
FROM
  volumes v
WHERE
  v.project_id = $1
`

func (q *Queries) GetKubernetesProjectBranches(ctx context.Context, projectID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getKubernetesProjectBranches, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var project_branch string
		if err := rows.Scan(&project_branch); err != nil {
			return nil, err
		}
		items = append(items, project_branch)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKubernetesServiceByName = `-- name: GetKubernetesServiceByName :one
SELECT
  id, project_id, project_branch, service_name, runtime, node_ports, ingress
FROM
  kubernetes_services
WHERE
  service_name = $1
  AND project_id = $2
  AND project_branch = $3
LIMIT 1
`

type GetKubernetesServiceByNameParams struct {
	ServiceName   string
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) GetKubernetesServiceByName(ctx context.Context, arg GetKubernetesServiceByNameParams) (KubernetesService, error) {
	row := q.db.QueryRow(ctx, getKubernetesServiceByName, arg.ServiceName, arg.ProjectID, arg.ProjectBranch)
	var i KubernetesService
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectBranch,
		&i.ServiceName,
		&i.Runtime,
		&i.NodePorts,
		&i.Ingress,
	)
	return i, err
}

const getKubernetesServicesByProject = `-- name: GetKubernetesServicesByProject :many
SELECT
  id, project_id, project_branch, service_name, runtime, node_ports, ingress
FROM
  kubernetes_services
WHERE
  project_id = $1
  AND project_branch = $2
ORDER BY
  service_name
`

type GetKubernetesServicesByProjectParams struct {
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) GetKubernetesServicesByProject(ctx context.Context, arg GetKubernetesServicesByProjectParams) ([]KubernetesService, error) {
	rows, err := q.db.Query(ctx, getKubernetesServicesByProject, arg.ProjectID, arg.ProjectBranch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []KubernetesService
	for rows.Next() {
		var i KubernetesService
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ProjectBranch,
			&i.ServiceName,
			&i.Runtime,
			&i.NodePorts,
			&i.Ingress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKubernetesServicesByUser = `-- name: GetKubernetesServicesByUser :many
SELECT
  s.id, s.project_id, s.project_branch, s.service_name, s.runtime, s.node_ports, s.ingress,
  p.name AS project_name
FROM
  kubernetes_services s
  JOIN projects p ON s.project_id = p.id
  JOIN user_projects up ON up.project_id = p.id
WHERE
  up.user_id = $1
ORDER BY
  p.name,
  s.service_name
`

type GetKubernetesServicesByUserRow struct {
	ID            uuid.UUID
	ProjectID     uuid.UUID
	ProjectBranch string
	ServiceName   string
	Runtime       Runtime
	NodePorts     []int32
	Ingress       pgtype.Text
	ProjectName   string
}

func (q *Queries) GetKubernetesServicesByUser(ctx context.Context, userID uuid.UUID) ([]GetKubernetesServicesByUserRow, error) {
	rows, err := q.db.Query(ctx, getKubernetesServicesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKubernetesServicesByUserRow
	for rows.Next() {
		var i GetKubernetesServicesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ProjectBranch,
			&i.ServiceName,
			&i.Runtime,
			&i.NodePorts,
			&i.Ingress,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKubernetesVolumeIdentifier = `-- name: GetKubernetesVolumeIdentifier :one
SELECT
  identifier
FROM
  kubernetes_volumes
WHERE
  volume_name = $1
  AND project_id = $2
  AND project_branch = $3
`

type GetKubernetesVolumeIdentifierParams struct {
	VolumeName    string
	ProjectID     uuid.UUID
	ProjectBranch string
}

func (q *Queries) GetKubernetesVolumeIdentifier(ctx context.Context, arg GetKubernetesVolumeIdentifierParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getKubernetesVolumeIdentifier, arg.VolumeName, arg.ProjectID, arg.ProjectBranch)
	var identifier uuid.UUID
	err := row.Scan(&identifier)
	return identifier, err
}

const getProject = `-- name: GetProject :one
SELECT
  id, name
FROM
  projects
WHERE
  id = $1
LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id uuid.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getProjectById = `-- name: GetProjectById :one
SELECT
  id,
  name
FROM
  projects
WHERE
  id = $1
`

func (q *Queries) GetProjectById(ctx context.Context, id uuid.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectById, id)
	var i Project
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getProjectByName = `-- name: GetProjectByName :one
SELECT
  id, name
FROM
  projects
WHERE
  name = $1
LIMIT 1
`

func (q *Queries) GetProjectByName(ctx context.Context, name string) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByName, name)
	var i Project
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getProjectsByUser = `-- name: GetProjectsByUser :many
SELECT
  p.id, p.name
FROM
  projects p
  JOIN user_projects up ON p.id = up.project_id
WHERE
  up.user_id = $1
ORDER BY
  p.name
`

func (q *Queries) GetProjectsByUser(ctx context.Context, userID uuid.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnusedKubernetesVolumeIdentifiers = `-- name: GetUnusedKubernetesVolumeIdentifiers :many
SELECT
  identifier
FROM
  kubernetes_volumes
WHERE
  project_id = $1
  AND project_branch = $2
  AND NOT volume_name = ANY ($3::text[])
`

type GetUnusedKubernetesVolumeIdentifiersParams struct {
	ProjectID      uuid.UUID
	ProjectBranch  string
	ExcludeVolumes []string
}

func (q *Queries) GetUnusedKubernetesVolumeIdentifiers(ctx context.Context, arg GetUnusedKubernetesVolumeIdentifiersParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getUnusedKubernetesVolumeIdentifiers, arg.ProjectID, arg.ProjectBranch, arg.ExcludeVolumes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var identifier uuid.UUID
		if err := rows.Scan(&identifier); err != nil {
			return nil, err
		}
		items = append(items, identifier)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByApiKey = `-- name: GetUserByApiKey :one
SELECT
  id, username, api_key
FROM
  users
WHERE
  api_key = $1
LIMIT 1
`

func (q *Queries) GetUserByApiKey(ctx context.Context, apiKey string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByApiKey, apiKey)
	var i User
	err := row.Scan(&i.ID, &i.Username, &i.ApiKey)
	return i, err
}

const isUserInProject = `-- name: IsUserInProject :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      user_projects
    WHERE
      user_id = $1
      AND project_id = $2)
`

type IsUserInProjectParams struct {
	UserID    uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) IsUserInProject(ctx context.Context, arg IsUserInProjectParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserInProject, arg.UserID, arg.ProjectID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const setKubernetesServiceIngress = `-- name: SetKubernetesServiceIngress :exec
UPDATE
  kubernetes_services
SET
  ingress = $2
WHERE
  id = $1
RETURNING
  id, project_id, project_branch, service_name, runtime, node_ports, ingress
`

type SetKubernetesServiceIngressParams struct {
	ID      uuid.UUID
	Ingress pgtype.Text
}

func (q *Queries) SetKubernetesServiceIngress(ctx context.Context, arg SetKubernetesServiceIngressParams) error {
	_, err := q.db.Exec(ctx, setKubernetesServiceIngress, arg.ID, arg.Ingress)
	return err
}

const setKubernetesServiceNodePorts = `-- name: SetKubernetesServiceNodePorts :exec
UPDATE
  kubernetes_services
SET
  node_ports = $2
WHERE
  id = $1
RETURNING
  id, project_id, project_branch, service_name, runtime, node_ports, ingress
`

type SetKubernetesServiceNodePortsParams struct {
	ID        uuid.UUID
	NodePorts []int32
}

func (q *Queries) SetKubernetesServiceNodePorts(ctx context.Context, arg SetKubernetesServiceNodePortsParams) error {
	_, err := q.db.Exec(ctx, setKubernetesServiceNodePorts, arg.ID, arg.NodePorts)
	return err
}
